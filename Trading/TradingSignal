import pandas as pd
import numpy as np
import talib
import random
import datetime
import matplotlib.pyplot as plt
import statsmodels.api as sm
from sklearn.metrics import classification_report, confusion_matrix

def formatBacktestdata(_ccy:str):
    # Formatting
    _tarCol = ['Open time', 'Open', 'High', 'Low', 'Volume', 'Close']
    _Dir = "C:\\Users\\LCYY\\Desktop\\CrytoTrade\\Data\\Binance\\"
    _filename = '{}USDT.csv'.format(_ccy)
    _histData = pd.read_csv(_Dir + _filename, dtype={'Open time':str})[_tarCol].dropna()
    _histData['datetime'] = pd.to_datetime(_histData['Open time'], format='%Y-%m-%d %H:%M:%S')
    _histData = _histData.sort_values('datetime').reset_index(drop=True)
    _histData['date'] = _histData.datetime.dt.date
    _histData['time'] = _histData.datetime.dt.time
    _histData['symbol'] = _ccy + '/' + 'USDT'
    _histData = _histData[['datetime', 'date', 'time', 'symbol'] + _tarCol]
    _histData = _histData.drop(columns=['Open time'], axis=1)
    return _histData
    
def getRandomPeriod(_date:list, _numDays:int):
    _minDate = datetime.date(2020, 12, 31)
    _maxDate = datetime.date(2021, 10, 31)
    _startPeriod = random.choice(_date)
    _endPeriod = _startPeriod + datetime.timedelta(days=_numDays)
    if (_startPeriod >= _minDate) and (_endPeriod <= _maxDate) :
        return _startPeriod, _endPeriod
    else:
        return getRandomPeriod(_date, _numDays)
        
def calRSI(_close:pd.Series, _window_length:int,_mode:str):
    delta = _close.diff()[1:]
    up, down = delta.clip(lower=0), delta.clip(upper=0).abs()
    if _mode == 'EWMA':
        # Calculate the RSI based on EWMA
        roll_up = up.ewm(span=_window_length).mean()
        roll_down = down.ewm(span=_window_length).mean()
    elif _mode == 'SMA':
        # Calculate the RSI based on SMA
        roll_up = up.rolling(_window_length).mean()
        roll_down = down.rolling(_window_length).mean()
    elif _mode == 'RMA':
        # Calculate the RSI based on RMA/SMMA/MMA
        alpha = 1 / _window_length
        roll_up = up.ewm(alpha=alpha).mean()
        roll_down = down.ewm(alpha=alpha).mean()
    rs = roll_up / roll_down
    rsi = 100.0 - (100.0 / (1.0 + rs))
    return pd.concat([pd.Series([0]), rsi])
    
def calSTOSC(_sto:pd.Series, _window_length:int):
    # Stochastic oscillator
    _SOSC = pd.Series([0]*_window_length + \
            [(_sto[i] - _sto[i:i+_window_length].min()) * 100 /
            (_sto[i:i+_window_length].max() - _sto[i:i+_window_length].min()) 
            for i in range(len(_sto)-_window_length)])
#     Readable code
#     _SOSC = []
#     for i in range(len(_sto)-_window_length):
#         _lookbackPeriod = _sto[i:i+_window_length]
#         _localmin, _localmax = _lookbackPeriod.min(), _lookbackPeriod.max()
#         _SOSC.append((_sto[i] - _localmin)/(_localmax - _localmin)*100)
#     _SOSC = pd.Series([0]*_window_length + _SOSC)
    return _SOSC
    
def calFastSlowK(_sto:pd.Series, _high:pd.Series, _low:pd.Series, _window_length:int, _smoother:int):
    # Stochastic Oscillator
    _localHigh = _high.rolling(_window_length).max()
    _localLow = _low.rolling(_window_length).min()
    _FastK = (_sto - _localLow) * 100 / (_localHigh - _localLow)
    _SlowK = _FastK.rolling(_smoother).mean()
    return _FastK, _SlowK
    
def calEMA(_close:pd.Series, _window_length:int):
    return _close.ewm(span=_window_length).mean()
    
def calMACD(_close:pd.Series, _windowK:int, _windowD:int, _windowS:int):
    _kLine = _close.ewm(span=_windowK).mean()
    _dLine = _close.ewm(span=_windowD).mean()
    _macd = _kLine-_dLine
    _macd_s = _macd.ewm(span=_windowS).mean()
    _histo = _macd - _macd_s
    return _macd, _macd_s, _histo
    
def calSuperTrend(_close:pd.Series, _high:pd.Series, _low:pd.Series, _window_length:int, _multiplier:int):
    # Close cross above SuperTrend = Buy
    # ATR
    TRHL = pd.DataFrame(_high - _low)
    TRHC = pd.DataFrame(abs(_high - _close.shift(1)))
    TRLC = pd.DataFrame(abs(_low - _close.shift(1)))
    TR = pd.concat([TRHL, TRHC, TRLC], axis = 1, join = 'inner').max(axis = 1)
    ATR = TR.ewm(_window_length).mean()
    # H/L AVG AND BASIC UPPER & LOWER BAND
    HLA = (_high + _low) / 2
    BUB = (HLA + _multiplier * ATR).dropna()
    BLB = (HLA - _multiplier * ATR).dropna()
    # FINAL BANDS
    final_bands = pd.DataFrame(columns = ['upper', 'lower'])
    final_bands.iloc[:,0] = [x for x in BUB - BUB]
    final_bands.iloc[:,1] = final_bands.iloc[:,0]
    for i in range(len(final_bands)):
        if i == 0:
            final_bands.iloc[i,0] = 0
            final_bands.iloc[i, 1] = 0
        else:
            # UPPER
            if (BUB[i] < final_bands.iloc[i-1,0]) | (_close[i-1] > final_bands.iloc[i-1,0]):
                final_bands.iloc[i,0] = BUB[i]
            else:
                final_bands.iloc[i,0] = final_bands.iloc[i-1,0]
            # LOWER
            if (BLB[i] > final_bands.iloc[i-1,1]) | (_close[i-1] < final_bands.iloc[i-1,1]):
                final_bands.iloc[i,1] = BLB[i]
            else:
                final_bands.iloc[i,1] = final_bands.iloc[i-1,1]
    # SUPERTREND
    supertrend = pd.DataFrame(columns = [f'supertrend_{_window_length}'])
    supertrend.iloc[:,0] = [x for x in final_bands['upper'] - final_bands['upper']]
    for i in range(len(supertrend)):
        if i == 0:
            supertrend.iloc[i, 0] = 0
        elif supertrend.iloc[i-1, 0] == final_bands.iloc[i-1, 0] and _close[i] < final_bands.iloc[i, 0]:
            supertrend.iloc[i, 0] = final_bands.iloc[i, 0]
        elif supertrend.iloc[i-1, 0] == final_bands.iloc[i-1, 0] and _close[i] > final_bands.iloc[i, 0]:
            supertrend.iloc[i, 0] = final_bands.iloc[i, 1]
        elif supertrend.iloc[i-1, 0] == final_bands.iloc[i-1, 1] and _close[i] > final_bands.iloc[i, 1]:
            supertrend.iloc[i, 0] = final_bands.iloc[i, 1]
        elif supertrend.iloc[i-1, 0] == final_bands.iloc[i-1, 1] and _close[i] < final_bands.iloc[i, 1]:
            supertrend.iloc[i, 0] = final_bands.iloc[i, 0]
    supertrend = supertrend.set_index(BUB.index)
    supertrend = supertrend.dropna()[1:]
    return pd.Series(supertrend.iloc[:, 0])
    
def Strat_FastSlowK(_fastK:float, _slowK:float, _thes:int):
    if ((_fastK < _thes) and (_slowK < _thes) and (_fastK > _slowK)):
        return 1
    elif ((_fastK > (100-_thes)) and (_slowK < (100-_thes)) and (_fastK < _slowK)):
        return -1
    else:
        return 0
    
def Strat_KDSwing(_fastK:float, _slowK:float, _thes:int):
    if ((_fastK < _thes) and (_slowK < _thes) and (abs(_fastK/_slowK-1) < 0.02)):
        return 1
    elif ((_fastK > (100-_thes)) and (_slowK < (100-_thes)) and (abs(_fastK/_slowK-1) < 0.02)):
        return -1
    else:
        return 0
    
def Strat_MACD(_macd:float, _macdS:float, _NmacdH:float):
    if (_macd > _macdS) and (_NmacdH > 0.75):
        return 1
    elif _macd < _macdS and (_NmacdH <= 0.25):
        return -1
    else:
        return 0
    
def Strat_BullishOversold(_close:float, _EMA:float, _ST:float, _SRSI:float, _SOS:float):
    return 1 if (((_SRSI+_SOS)/2 < 20) and ((_close > _EMA) or (_close > _ST))) else 0
    
def Gen_backtesting_data(_ccy:str):
    # Load data
    _data = formatBacktestdata(_ccy)
    _startDate, _endDate = getRandomPeriod(_date=_data.date.unique(), _numDays=30)
    _train = _data[(_data.date >= _startDate) & (_data.date <= _endDate)].reset_index(drop=True)
    _test = _data[(_data.date >= datetime.date(2021, 10, 31))].reset_index(drop=True)
    for data in [_train, _test]:
        # Normalization
        data['N_Close'] = ((data.Close - data.Close.min())/(data.Close.max() - data.Close.min()))
        data['SOS'] = calSTOSC(_sto=data['Close'], _window_length=14)
        data['SFastK'], data['SSlowK'] = calFastSlowK(_sto=data['Close'], _high=data['High'], _low=data['Low'], \
                                                      _window_length=14, _smoother=3)
        data['RSI'] = calRSI(data['N_Close'], _window_length=14, _mode='EWMA')
        data['SRSI'] = calSTOSC(_sto=data['RSI'], _window_length=14)
        data['ST'] = calSuperTrend(_close=data['Close'], _high=data['High'], 
                                   _low=data['Low'], _window_length=14, _multiplier=3)
        data['MACD'], data['MACD_SLine'], data['MACD_Hist'] = calMACD(_close=data['Close'], _windowK=12, \
                                                                _windowD=26, _windowS=9)
        data['N_MACD_Hist'] = ((data.MACD_Hist - data.MACD_Hist.min())/(data.MACD_Hist.max() - data.MACD_Hist.min()))
    return _train, _test
    
def Gen_backtesting_signal(_data:pd.DataFrame):
    # Signal
    _signaldf = pd.DataFrame(data=[x for x in _data.date], columns=['date'])
    _signaldf['time'] = _data.time
    # Volume
    for _vlag in [0, 1, 2, 3, 4, 5, 7, 14, 28]:
        _signaldf['MinMaxVolume_LAG_{}'.format(_vlag)] = ((_data.Volume - _data.Volume.min()) / \
                                          (_data.Volume.max() - _data.Volume.min())).shift(_vlag)
    # Oversold
    for _threshold in [20, 25, 30, 40]:
        # Stochastic Oscillator
        _signaldf['Oversold_S.OSC_{}'.format(_threshold)] = _data['SOS'].apply(lambda x : -1 if x \
            <= _threshold else 1 if x >= (100-_threshold) else 0)
        # RSI
        _signaldf['Oversold_RSI_{}'.format(_threshold)] = _data['RSI'].apply(lambda x : -1 if x \
            <= _threshold else 1 if x >= (100-_threshold) else 0)
        # Stochastic RSI
        _signaldf['Oversold_S.RSI_{}'.format(_threshold)] = _data['SRSI'].apply(lambda x : -1 if x \
            <= _threshold else 1 if x >= (100-_threshold) else 0)
        # FastK, SlowK
        _signaldf['Oversold_FastSlowK_{}'.format(_threshold)] = _data[['SFastK', 'SSlowK']].apply(lambda x : 
            Strat_FastSlowK(_fastK = x[0], _slowK = x[1], _thes=_threshold), axis=1)
        _signaldf['Oversold_KD_{}'.format(_threshold)] = _data[['SFastK', 'SSlowK']].apply(lambda x : 
            Strat_KDSwing(_fastK = x[0], _slowK = x[1], _thes=_threshold), axis=1)
    # Bullish Trend
    # Super Trend
    _signaldf['SuperTrend'] = _data[['Close', 'ST']].apply(lambda x : -1 if x[0] <= x[1] else 1, axis=1)
    # MACD
    _signaldf['MACD'] = _data[['MACD', 'MACD_SLine', 'MACD_Hist']].apply(lambda x :
                        Strat_MACD(_macd = x[0], _macdS = x[1], _NmacdH = x[2]), axis=1)
    # EMA
    for _ema in [3, 7, 14, 28]:
        _data['EMA{}'.format(_ema)] = _data.Close.ewm(span=_ema).mean()
        _signaldf['EMA_{}'.format(_ema)] = _data[['Close', 'EMA{}'.format(_ema)]].apply(lambda x : -1 if x[0] <= x[1] else 1, axis=1)
    # Mean-Revert & Short-term Momentum
    for _lag in [1, 2, 3, 4, 5, 7, 14, 28]:
        _data['LAG_{}'.format(_lag)] = (_data.Close/_data.Close.shift(_lag)-1)
        _signaldf['MeanRevert_LAG_{}'.format(_lag)] = _data['LAG_{}'.format(_lag)].apply(lambda x : 1 if x < 0 else 0)
        _signaldf['CarryMomentum_LAG_{}'.format(_lag)] = _data['LAG_{}'.format(_lag)].apply(lambda x : 1 if x > 0 else 0)
    # Complicated
    _signaldf['BullishOversold'] = _data[['Close', 'EMA{}'.format(14), 'ST', 'SRSI', 'SOS']].apply(lambda \
                              x:Strat_BullishOversold(x[0], x[1], x[2], x[3], x[4]), axis=1)
    # Y
    _signaldf['Actual_Y'] = (_data['Close'].shift(-1)/_data['Close']-1).apply(lambda x : 1 if x > 0 else 0)
    
    return _signaldf[(_signaldf.date > min(_signaldf.date)) & \
            (_signaldf.date < max(_signaldf.date))].reset_index(drop=True)
            
def Gen_backtesting_fitmodel(_testPeriod:pd.DataFrame):
    # Model fitting
    X = _testPeriod.drop(['date', 'time', 'Actual_Y'], axis=1)
    y = _testPeriod['Actual_Y']
    model = sm.Logit(y, X)
    logi = model.fit(method='newton')
    display(logi.summary())
    display(confusion_matrix(y, (logi.predict(X) >= 0.5).astype(int)))
    print(classification_report(y, (logi.predict(X) >= 0.5).astype(int)))
    
# CCY
_ccyList = ['BTC', 'ETH', 'SOL', 'AVAX', 'ADA']#, 'BNB', 'DOGE', 'DOT', 'XRP']

# Gen Data
_SOLTrain, _SOLTest = Gen_backtesting_data('SOL')
_ETHTrain, _ETHTest = Gen_backtesting_data('ETH')
_BTCTrain, _BTCTest = Gen_backtesting_data('BTC')
_AVAXTrain, _AVAXTest = Gen_backtesting_data('AVAX')
_ADATrain, _ADATest = Gen_backtesting_data('ADA')

# Signal
_Signal_SOLTrain, _Signal_SOLTest = Gen_backtesting_signal(_SOLTrain), Gen_backtesting_signal(_SOLTest)
_Signal_ETHTrain, _Signal_ETHTest = Gen_backtesting_signal(_ETHTrain), Gen_backtesting_signal(_ETHTest)
_Signal_BTCTrain, _Signal_BTCTest = Gen_backtesting_signal(_BTCTrain), Gen_backtesting_signal(_BTCTest)
_Signal_AVAXTrain, _Signal_AVAXTest = Gen_backtesting_signal(_AVAXTrain), Gen_backtesting_signal(_AVAXTest)
_Signal_ADATrain, _Signal_ADATest = Gen_backtesting_signal(_ADATrain), Gen_backtesting_signal(_ADATest)

# Change different df for testing
Gen_backtesting_fitmodel(_Signal_SOLTrain)
Gen_backtesting_fitmodel(_Signal_SOLTest)
