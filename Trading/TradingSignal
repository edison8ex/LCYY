import pandas as pd
import os
import datetime
import matplotlib.pyplot as plt

def formatBacktestdata(_ccy):
    # Formatting
    _tarCol = ['Open time', 'Open', 'High', 'Low', 'Volume', 'Close']
    _Dir = os.getcwd()
    _filename = '{}USDT.xlsx'.format(_ccy)
    _histData = pd.read_excel(_Dir + _filename, dtype={'Open time':str})[_tarCol].dropna()
    _histData['datetime'] = pd.to_datetime(_histData['Open time'], format='%Y-%m-%d %H:%M:%S')
    _histData = _histData.sort_values('datetime').reset_index(drop=True)
    _histData['date'] = _histData.datetime.dt.date
    _histData['time'] = _histData.datetime.dt.time
    _histData['symbol'] = _ccy + '/' + 'USDT'
    _histData = _histData[['datetime', 'date', 'time', 'symbol'] + _tarCol]
    _histData = _histData.drop(columns=['Open time'], axis=1)
    return _histData
    
def calRSI(_close:pd.Series, _window_length:int,_mode:str):
    delta = _close.diff()[1:]
    up, down = delta.clip(lower=0), delta.clip(upper=0).abs()
    if _mode == 'EWMA':
        # Calculate the RSI based on EWMA
        roll_up = up.ewm(span=_window_length).mean()
        roll_down = down.ewm(span=_window_length).mean()
    elif _mode == 'SMA':
        # Calculate the RSI based on SMA
        roll_up = up.rolling(_window_length).mean()
        roll_down = down.rolling(_window_length).mean()
    elif _mode == 'RMA':
        # Calculate the RSI based on RMA/SMMA/MMA
        alpha = 1 / _window_length
        roll_up = up.ewm(alpha=alpha).mean()
        roll_down = down.ewm(alpha=alpha).mean()
    rs = roll_up / roll_down
    rsi = 100.0 - (100.0 / (1.0 + rs))
    return pd.concat([pd.Series([0]), rsi])
    
def calSTOSC(_sto:pd.Series, _window_length:int):
    # Stochastic Oscillator
    _SOSC = pd.Series([0]*_window_length + \
            [(_sto[i] - _sto[i:i+_window_length].min()) * 100 /
            (_sto[i:i+_window_length].max() - _sto[i:i+_window_length].min()) 
            for i in range(len(_sto)-_window_length)])
#     Readable code
#     _SOSC = []
#     for i in range(len(_sto)-_window_length):
#         _lookbackPeriod = _sto[i:i+_window_length]
#         _localmin, _localmax = _lookbackPeriod.min(), _lookbackPeriod.max()
#         _SOSC.append((_sto[i] - _localmin)/(_localmax - _localmin)*100)
#     _SOSC = pd.Series([0]*_window_length + _SOSC)
    return _SOSC
    
# Window length for moving average
_lookback = 14
# Super trend multiplier
_multiplier = 3
# CCY
_ccy = 'SOL'

# Load data
data = formatBacktestdata(_ccy)
display(data)

# OS, RSI, SRSI
data['OS'] = calSTOSC(_sto=data['Close'], _window_length=_lookback)
data['RSI'] = calRSI(data['Close'], _window_length=_lookback, _mode='EWMA')
data['SRSI'] = calSTOSC(_sto=data['RSI'], _window_length=_lookback)
display(data)

# Compare graphically
fig, ax1 = plt.subplots(figsize=(24, 6))
ax2 = ax1.twinx()
#ax1.plot(data.datetime[-500:], data.RSI[-500:], 'r-')
#ax1.plot(data.datetime[-500:], data.SRSI[-500:], 'g-')
#ax1.plot(data.datetime[-500:], data.SOS[-500:], 'y-')
ax2.plot(data.datetime[-500:], data.Close[-500:], 'b-')
ax2.plot(data.datetime[-500:], st[-500:], 'r-')
plt.show()

# ATR
TRHL = pd.DataFrame(data.High - data.Low)
TRHC = pd.DataFrame(abs(data.High - data.Close.shift(1)))
TRLC = pd.DataFrame(abs(data.Low - data.Close.shift(1)))
TR = pd.concat([TRHL, TRHC, TRLC], axis = 1, join = 'inner').max(axis = 1)
ATR = tr.ewm(_lookback).mean()
# H/L AVG AND BASIC UPPER & LOWER BAND
HLA = (data.High + data.Low) / 2
BUB = (HLA + _multiplier * ATR).dropna()
BLB = (HLA - _multiplier * ATR).dropna()
# FINAL BANDS
final_bands = pd.DataFrame(columns = ['upper', 'lower'])
final_bands.iloc[:,0] = [x for x in BUB - BUB]
final_bands.iloc[:,1] = final_bands.iloc[:,0]
for i in range(len(final_bands)):
    if i == 0:
        final_bands.iloc[i,0] = 0
        final_bands.iloc[i, 1] = 0
    else:
        # UPPER
        if (BUB[i] < final_bands.iloc[i-1,0]) | (data.Close[i-1] > final_bands.iloc[i-1,0]):
            final_bands.iloc[i,0] = BUB[i]
        else:
            final_bands.iloc[i,0] = final_bands.iloc[i-1,0]
        # LOWER
        if (BLB[i] > final_bands.iloc[i-1,1]) | (data.Close[i-1] < final_bands.iloc[i-1,1]):
            final_bands.iloc[i,1] = BLB[i]
        else:
            final_bands.iloc[i,1] = final_bands.iloc[i-1,1]
# SUPERTREND
supertrend = pd.DataFrame(columns = [f'supertrend_{_lookback}'])
supertrend.iloc[:,0] = [x for x in final_bands['upper'] - final_bands['upper']]
for i in range(len(supertrend)):
    if i == 0:
        supertrend.iloc[i, 0] = 0
    elif supertrend.iloc[i-1, 0] == final_bands.iloc[i-1, 0] and data.Close[i] < final_bands.iloc[i, 0]:
        supertrend.iloc[i, 0] = final_bands.iloc[i, 0]
    elif supertrend.iloc[i-1, 0] == final_bands.iloc[i-1, 0] and data.Close[i] > final_bands.iloc[i, 0]:
        supertrend.iloc[i, 0] = final_bands.iloc[i, 1]
    elif supertrend.iloc[i-1, 0] == final_bands.iloc[i-1, 1] and data.Close[i] > final_bands.iloc[i, 1]:
        supertrend.iloc[i, 0] = final_bands.iloc[i, 1]
    elif supertrend.iloc[i-1, 0] == final_bands.iloc[i-1, 1] and data.Close[i] < final_bands.iloc[i, 1]:
        supertrend.iloc[i, 0] = final_bands.iloc[i, 0]
supertrend = supertrend.set_index(upper_band.index)
supertrend = supertrend.dropna()[1:]
# ST UPTREND/DOWNTREND
upt = []
dt = []
data.Close = data.Close.iloc[len(data.Close) - len(supertrend):]
for i in range(len(supertrend)):
    if data.Close[i] > supertrend.iloc[i, 0]:
        upt.append(supertrend.iloc[i, 0])
        dt.append(np.nan)
    elif data.Close[i] < supertrend.iloc[i, 0]:
        upt.append(np.nan)
        dt.append(supertrend.iloc[i, 0])
    else:
        upt.append(np.nan)
        dt.append(np.nan)
st, upt, dt = pd.Series(supertrend.iloc[:, 0]), pd.Series(upt), pd.Series(dt)
upt.index, dt.index = supertrend.index, supertrend.index
